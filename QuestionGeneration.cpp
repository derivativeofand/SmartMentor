#include "QuestionGeneration.h"

/**
 * \brief Constructor for QuestionGeneration object
 */
QuestionGeneration::QuestionGeneration()
{
}

/**
 * \brief Replaces math symbols with actual words
 * \param text the question text that was generated
 * \return void
 * 
 * This method uses a question text generated from the AI and replaces all the math symbols into actual words 
 */
void QuestionGeneration::replaceMathSymbols(string& text) {
    vector<pair<string, string>> replacements = {
        {"<=", " is less than or equal to "},
        {">=", " is greater than or equal to "},
        {"!=", " is not equal to "},
        {"<", " is less than "},
        {">", " is greater than "},
        {"+", " plus "},
        {"-", " minus "},
        {"*", " times "},
        {"/", " divided by "},
        {"=", " equals "},
        {"^", " to the power of "},
        {"√", " square root of "},
        {"π", " pi "},
        {"%", " percent "}
    };

    for (const auto& [symbol, word] : replacements) {
        size_t pos = 0;
        while ((pos = text.find(symbol, pos)) != string::npos) {
            text.replace(pos, symbol.length(), word);
            pos += word.length();
        }
    }

    text = regex_replace(text, regex("\\s+"), " ");
    text = regex_replace(text, regex("^\\s+|\\s+$"), "");
}

/**
 * \brief Generates a quiz of questions using ollama AI.
 * \param user current user
 * \param difficulty how hard the question should be.
 * \param category subject of the question.
 * \param numQuestions number of questions to be generated.
 * \return a quiz object full of questions generated by the AI model.
 * 
 * This method used the paramaters to generate a prompt for the AI to use then takes it response and using regex to parse, converts it into question objects to be put into the quiz object.
 */
Quiz *QuestionGeneration::generateQuiz(User *user, int difficulty, string category, int numQuestions)
{
    string prompt =
        "Generate a single multiple-choice " + category + " question of " + to_string(difficulty) +
        " difficulty. "
        "Format the response exactly like this:\n\n"
        "Q: [Your question here] (single line)\n"
        "A. [Option text]\n"
        "B. [Option text]\n"
        "C. [Option text]\n"
        "D. [Option text]\n"
        "Answer: [Correct option letter]\n\n"
        "Ensure the correct answer is accurate and consistent with the question. "
        "The other options (distractors) should be plausible but incorrect. "
        "Avoid ambiguity in the question and options. "
        "Do not include any extra text, explanations, or multi-line content.";

    regex pattern(R"(Q:\s*(.+?)\s*A\.\s*(.+?)\s*B\.\s*(.+?)\s*C\.\s*(.+?)\s*D\.\s*(.+?)\s*Answer:\s*([A-D]))");
    vector<Question *> questions;
    set<string> unique_questions;
    for (int i = 0; i < numQuestions; ++i)
    {
        ollama::response response;
        if (category.compare("Math") == 0)
        {
            response = ollama::generate("llama3.2", prompt);
        }
        else
        {
            response = ollama::generate("phi4-mini", prompt);
        }
        string raw_output = response.as_simple_string();
        smatch match;
        if (std::regex_search(raw_output, match, pattern))
        {
            string question = match[1];
            if (unique_questions.count(question))
            {
                cout << "Duplicate question skipped: " << question << "\n";
                continue;
            }
            unique_questions.insert(question);
            vector<string> options = {match[2], match[3], match[4], match[5]};
            
            if (category == "Math") {
                replaceMathSymbols(question);
                for (auto& option : options) {
                    replaceMathSymbols(option);
                }
            }
            Question *q = new Question(question, {match[2], match[3], match[4], match[5]}, ((string)match[6]).at(0) - 'A', difficulty, category);
            questions.push_back(q);
        }
        else
        {
            cout << "Failed to parse the response. Skipping.\n";
        }
    }
    Quiz *quiz = new Quiz(questions, user);
    return quiz;
}
